import multiprocessing
import numpy as np
import easyocr
import mss
import time
import pyautogui
from PIL import ImageGrab

# Функция для распознавания текста на экране и клика по определенным словам
def ocr_and_click_process():
    # Список слов, которые нужно найти
    words_to_find = ["bone", "xiphoid", "living", "blood", "blue"]
    # Задержка перед началом работы для подготовки
    time.sleep(5)
    # Инициализация читателя EasyOCR для английского языка
    reader = easyocr.Reader(['en'])

    while True:
        # Нажатие клавиши Alt для возможной активации окна
        pyautogui.keyDown('alt')
        # Захват экрана с помощью mss в заданной области
        with mss.mss() as sct:
            monitor = {"top": 0, "left": 0, "width": 1920, "height": 800}
            screenshot = sct.grab(monitor)
            img = np.array(screenshot)

        # Распознавание текста на скриншоте с деталями (координаты и текст)
        result = reader.readtext(img, detail=1)

        # Обработка каждого найденного текста
        for detection in result:
            text = detection[1]  # Извлечение текста
            bbox = detection[0]  # Извлечение координат bounding box

            # Проверка, содержится ли искомое слово в тексте
            for word in words_to_find:
                if word.lower() in text.lower():
                    # Вычисление центра области текста
                    x_center = (bbox[0][0] + bbox[2][0]) / 2
                    y_center = (bbox[0][1] + bbox[2][1]) / 2
                    time.sleep(15)  # Задержка перед кликом
                    # Правый клик мышью по центру найденного слова
                    pyautogui.click(x=x_center, y=y_center, button='right')
                    time.sleep(1)  # Задержка после клика
                    print(f"Клик правой кнопкой мыши по слову: {word}")
                    break
        time.sleep(1)  # Задержка между итерациями цикла

# Функция для работы с цветовой маской в пространстве LAB и кликов по найденным областям
def mask_click_process():
    import cv2
    import numpy as np
    from PIL import ImageGrab
    import pyautogui
    import time

    # Определение диапазонов для цветового пространства LAB
    l_min, l_max = 0, 255
    a_min, a_max = 172, 255
    b_min, b_max = 149, 177
    min_area = 10  # Минимальная площадь контура для обработки

    # Вспомогательная функция для захвата скриншота
    def take_screenshot():
        # Захват области экрана и преобразование в формат BGR
        screenshot = np.array(ImageGrab.grab(bbox=(0, 0, 1920, 800)))
        return cv2.cvtColor(screenshot, cv2.COLOR_RGB2BGR)

    # Вспомогательная функция для создания маски и поиска контуров
    def create_mask(screenshot):
        # Преобразование изображения в цветовое пространство LAB
        lab = cv2.cvtColor(screenshot, cv2.COLOR_BGR2LAB)
        L, A, B = cv2.split(lab)  # Разделение на каналы L, A, B
        # Создание масок для каждого канала по заданным диапазонам
        mask_L = cv2.inRange(L, l_min, l_max)
        mask_A = cv2.inRange(A, a_min, a_max)
        mask_B = cv2.inRange(B, b_min, b_max)
        # Объединение масок для получения итоговой маски
        mask = cv2.bitwise_and(mask_L, cv2.bitwise_and(mask_A, mask_B))

        # Поиск контуров на маске
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        # Фильтрация контуров по минимальной площади
        filtered_contours = [contour for contour in contours if cv2.contourArea(contour) > min_area]
        return mask, filtered_contours

    # Вспомогательная функция для клика по первому найденному контуру
    def auto_click_on_mask(contours):
        if contours:  # Если есть подходящие контуры
            contour = contours[0]  # Берем первый контур
            x, y, w, h = cv2.boundingRect(contour)  # Получаем координаты и размеры
            click_x = x + w // 2  # Центр по X
            click_y = y + h  # Нижняя точка по Y
            pyautogui.rightClick(click_x, click_y)  # Правый клик
            time.sleep(15)  # Задержка после клика
            print(f"Клик на маске: ({click_x}, {click_y})")

    # Основная функция процесса
    def main():
        while True:
            screenshot = take_screenshot()  # Захват экрана
            mask, contours = create_mask(screenshot)  # Создание маски и поиск контуров
            auto_click_on_mask(contours)  # Клик по контуру
            time.sleep(1)  # Задержка между итерациями

    main()  # Запуск основного цикла

# Функция для поиска пикселя определенного цвета и клика по нему
def find_pixel_and_click_process():
    time.sleep(5)  # Задержка перед началом
    target_color = (205, 118, 46)  # Целевой цвет в формате RGB
    offset_x = 50  # Смещение по X для клика
    offset_y = 50  # Смещение по Y для клика
    search_width = 1920  # Ширина области поиска
    search_height = 800  # Высота области поиска

    # Вспомогательная функция для поиска пикселя и клика
    def find_pixel_and_click(color):
        screenshot = ImageGrab.grab()  # Захват всего экрана
        width, height = screenshot.size  # Получение размеров экрана
        # Определение области поиска в центре экрана
        start_x = (width - search_width) // 2
        start_y = (height - search_height) // 2
        end_x = start_x + search_width
        end_y = start_y + search_height
        pixels = screenshot.load()  # Загрузка пикселей изображения

        # Поиск пикселя с целевым цветом
        for x in range(start_x, end_x):
            for y in range(start_y, end_y):
                if pixels[x, y][:3] == color:  # Сравнение цвета
                    click_x = x + offset_x  # Вычисление координат клика
                    click_y = y + offset_y
                    # Ограничение координат в пределах экрана
                    click_x = min(max(0, click_x), width - 1)
                    click_y = min(max(0, click_y), height - 1)
                    print(f"Найден пиксель с цветом {color} на координатах ({x}, {y}), кликаю на ({click_x}, {click_y})")
                    pyautogui.rightClick(click_x, click_y)  # Правый клик
                    time.sleep(20)  # Задержка после клика
                    return True
        time.sleep(10)  # Задержка, если пиксель не найден
        print(f"Пиксель с цветом {color} не найден.")
        return False

    while True:
        find_pixel_and_click(target_color)  # Запуск поиска в бесконечном цикле

# Функция для периодического клика в центре экрана
def center_click_process():
    while True:
        screen_width, screen_height = pyautogui.size()  # Получение размеров экрана
        center_x = screen_width // 2  # Центр по X
        center_y = screen_height // 2  # Центр по Y
        pyautogui.moveTo(center_x, center_y)  # Перемещение мыши в центр
        pyautogui.click(button='right')  # Правый клик
        time.sleep(120)  # Задержка 2 минуты между кликами

# Функция для перемещения мыши в центр, если она находится на краю экрана
def move_mouse_to_center_on_edge():
    screen_width, screen_height = 1920, 1080  # Фиксированные размеры экрана
    center_x, center_y = screen_width // 2, screen_height // 2  # Центр экрана

    while True:
        x, y = pyautogui.position()  # Текущие координаты мыши
        # Проверка, находится ли мышь на краю экрана
        if x <= 0 or x >= screen_width - 1 or y <= 0 or y >= screen_height - 1:
            pyautogui.moveTo(center_x, center_y)  # Перемещение в центр
            pyautogui.rightClick(center_x, center_y)  # Правый клик
        time.sleep(0.01)  # Быстрая проверка положения мыши

# Основной блок для запуска процессов
if __name__ == '__main__':
    processes = []  # Список для хранения процессов

    # Создание и запуск процесса для распознавания текста
    ocr_process = multiprocessing.Process(target=ocr_and_click_process)
    processes.append(ocr_process)
    ocr_process.start()

    # Создание и запуск процесса для работы с масками
    mask_process = multiprocessing.Process(target=mask_click_process)
    processes.append(mask_process)
    mask_process.start()

    # Создание и запуск процесса для поиска пикселя
    pixel_process = multiprocessing.Process(target=find_pixel_and_click_process)
    processes.append(pixel_process)
    pixel_process.start()

    # Создание и запуск процесса для кликов в центре
    center_process = multiprocessing.Process(target=center_click_process)
    processes.append(center_process)
    center_process.start()

    # Создание и запуск процесса для контроля положения мыши
    move_mouse_process = multiprocessing.Process(target=move_mouse_to_center_on_edge)
    processes.append(move_mouse_process)
    move_mouse_process.start()

    # Ожидание завершения всех процессов (в данном случае бесконечно)
    for process in processes:
        process.join()
